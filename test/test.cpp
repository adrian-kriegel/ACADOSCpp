
#include <gtest/gtest.h>

#include <ACADOSCpp/Capsule.hpp>

using namespace acados::solver;

void test_capsule(Capsule &ca) {

  int print_level = 0;
  ca.set_solver_option("print_level", &print_level);

  // check that dims matches the exported values TODO: assert entire dims
  // struct
  EXPECT_EQ(ca.dims().N, 20);

  for (uint i = 0; i < ca.dims().N; ++i) {
    EXPECT_EQ(ca.dims().nx[i], 6);
    EXPECT_EQ(ca.dims().nu[i], 3);
  }

  const int n = ca.dims().N;
  const int nx = ca.dims().nx[0];
  const int nu = ca.dims().nu[0];
  const int num_lbx0 = ca.get_constraint_dims(0, "lbx");
  const int num_ubx0 = ca.get_constraint_dims(0, "ubx");

  EXPECT_EQ(num_ubx0, 0);
  EXPECT_EQ(num_lbx0, 0);

  // initial conditions
  std::vector<double> lbx0(num_lbx0, 0.0);
  std::vector<double> ubx0(num_lbx0, 0.0);
  // vector::data() is nullptr if capacity is zero
  // set_constraints_for_stage complains if we pass nullptr
  lbx0.reserve(lbx0.size() + 1);
  ubx0.reserve(ubx0.size() + 1);

  // initialization for state values (repeated )
  std::vector<double> x_init(nx, 0.0);

  // initial value for control input
  std::vector<double> u0(nu, 0.0);

  // container for the output state trajectory
  std::vector<double> xtraj(nx * (n + 1), 0.0);
  // container for the output controls trajectory
  std::vector<double> utraj(nu * n, 0.0);

  ca.set_constraints_for_stage(0, "lbx", lbx0.data());
  ca.set_constraints_for_stage(0, "ubx", ubx0.data());

  // prepare evaluation
  int NTIMINGS = 10;
  double min_time = 1e12;
  double kkt_norm_inf;
  double elapsed_time;
  int sqp_iter;
  // solve ocp in loop
  int rti_phase = 0;

  for (int ii = 0; ii < NTIMINGS; ii++) {
    // initialize solution
    for (int i = 0; i < n; i++) {
      ca.set_output(i, "x", x_init.data());
      ca.set_output(i, "u", u0.data());
    }

    ca.set_output(n, "x", x_init.data());

    ca.set_option("rti_phase", &rti_phase);

    ca.solve();

    ca.get(&elapsed_time, "time_tot");

    min_time = std::min(elapsed_time, min_time);
  }

  /* print solution and statistics */
  for (int ii = 0; ii <= ca.dims().N; ii++) {
    ca.get_output(&xtraj[ii * nx], ii, "x");
  }

  for (int ii = 0; ii < ca.dims().N; ii++) {
    ca.get_output(&utraj[ii * nu], ii, "u");
  }

  // just checking a couple of hard coded values takeen from the example
  // generated by ACADOS I'm assuming that if those are correct, the entire
  // solution is correct, as there is no reason to assume that the CPP wrapper
  // messed up the solver that bad.
  EXPECT_NEAR(xtraj[0], 0.0, 1e-5);
  EXPECT_NEAR(xtraj.back(), 0.0, 1e-5);
  EXPECT_NEAR(utraj[0], 0.0, 1e-5);
  EXPECT_NEAR(utraj.back(), 0.0, 1e-5);
}

/**
 * This is a C++ified version of the example program that can be optionally
 * generated with ACADOS with added assertions.
 */
TEST(TestACADOSCpp, ExampleProgram) {

  Capsule ca("libacados_ocp_solver_test_model.so", "test_model");

  test_capsule(ca);
}

TEST(TestACADOSCpp, MoveCTor) {

  Capsule ca1("libacados_ocp_solver_test_model.so", "test_model");

  Capsule ca2 = std::move(ca1);

  EXPECT_EQ(ca1.get_dl_handle(), nullptr);
  EXPECT_EQ(ca1.get_prefix(), "");
  EXPECT_EQ(ca1.get_capsule_ptr(), nullptr);

  test_capsule(ca2);
}
